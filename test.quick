extern func puts(str String) UInt
extern func malloc(size UInt) *Void
extern func free(ptr *Void) Void

enum Name
{
    Albert,
    Benjamin,
    Carson,
    Derek,
}

union SimpleUnion
{
    a Int;
    b Bool;
    c Int;
    d String;
}

union GenericUnion<A, B>
{
    a A;
    b B;
}

func main() Int32
{
    const constant = 4;
    val arrayWithConstSize [constant]Int = [0; constant];
    val copyOfArrayWithConstSize [4]Int = arrayWithConstSize;

    val someonesName = Name.Carson;

    var genericUnion = GenericUnion.<Int32, Int64> { b = 0 };
    genericUnion.a = 5 as Int32;
    genericUnion.b = 8 as Int64;
    val testUnionAccess = genericUnion.b;
    val unionTag = genericUnion as Tag;
    val otherTag = GenericUnion.<Int32, Int64>.b;

    var function *func(Int, Int) Int = &add;
    function.*(1, 2);

    defer
    {
        puts("defer in main");
    }

    var inferTwoD = [1, 5];
    var inferPoint = Point { x = 1, y = 2 };

    val a = 542 + 54578 / 3;
    var b Int = a * 2;
    val c = b /= b / 4;

    val str String = "hello world";
    puts(str);

    var byte UInt8 = 255 as UInt8;
    var bytePtr *UInt8 = &byte;
    var otherByte UInt8 = bytePtr.*;

    /*
    /*
    var point: Point = Point { x: 1, y: 2 };
    var pointPtr: Point* = &point;
    var otherPoint: Point = *pointPtr;
    var pointX: Int = pointPtr.x;
    var pointSize: Int = sizeof Point;
    */
    */

    var heapPoint *Point = malloc(sizeof Point) as *Point;
    heapPoint.* = Point { x = 5, y = 5 };
    val fromHeapX = heapPoint.x;
    free(heapPoint);

    var myArray [3]Int = makeArray(1, 777, 3);
    var myArrayCopy [3]Int = takeArray(myArray);
    var otherCopy [3]Int = myArrayCopy;
    var repeatArray [400]Int = [1, 2, 3, 4; 100];
    var repeatStringArray [400]String = ["a", "bb", "ccc", "dddd"; 100];
    repeatStringArray[0] = "hello";
    puts(repeatStringArray[377]);

    var multiA [2][3]String = [["a", "b", "ccc"], ["d", "e", "f"]];
    var multiB [2][3]String = multiA;
    puts(multiA[1][2]);

    var xy [2]Point = [
        Point
        {
            x = 5,
            y = 7,
        },
        Point
        {
            x = 5,
            y = 7,
        },
    ];

    var x Int = (xy[0].x);
    var y Int = xy[0].y;

    Point.Multiply(&xy[0], &xy[1]);
    xy[0].Multiply(&xy[1]);
    // xy[0].GenericThing.<*Point>(&xy[1]);

    Point.Static(x);

    var ch Char = 'a';

    var boolean Bool = true && false || (5 <= 88);

    {
        {
            puts("in
            a block");
        }
    }

    if (boolean)
    {
        puts("boolean is true");
    }

    if (boolean && boolean)
    {
        puts("boolean is true");
    }
    else if (boolean)
    {

    }
    else
    {

    }

    while (x == 5 && y == 7)
    {
        x = 3;
    }

    for (i of -10 < 10)
    {
        defer puts("defer in loop1");
        defer puts("defer in loop2");
    }

    for (i of zero() <= 10)
    {
        defer puts("defer in loop");

        {
            defer puts("defer in block in loop");
        }

        defer puts("defer later in loop");

        return 0;
    }

    for (i of 10 >= 0 by -1)
    {

    }

    for (i of 10 >= 0 by -1)
    {

    }

    for (default of 10.0 >= 0.0 by -1.0);

    val si = 1;
    switch (si)
    case (1)
    {
        puts("1");
    }
    case (2)
    {
        puts("2");
    }
    case (3) puts("3");
    else
    {
        puts("other");
    }

    switch (si)
    case (1) puts("1");
    case (2) puts("2");
    case (3) puts("3");
    else puts("other");

    hello(
        a,
        b,
    );

    val genericResult Int = genericFunction.<Int, Bool>(777, true);
    val genericResult2 = genericFunction.<Bool, Bool>(false, true);
    val genericResult3 = genericFunction.<Bool, Bool>(false, true);

    val nonGenericPtr = &genericFunction.<Int, Int>;

    val genericStruct = GenericStruct.<Int, Int> { a = 5, b = 6 };
    val genericStruct2 = GenericStruct.<Bool, Int> { a = true, b = 6 };
    val genericStruct3 = GenericStruct.<Int, Int> { a = 5, b = 6 };
    val genericStruct4 GenericStruct.<Int, Int> = returnsGeneric();

    return 0;
}

func returnsGeneric() GenericStruct.<Int, Int> {
    return GenericStruct.<Int, Int> { a = 5, b = 6 };
}

func add(a Int, b Int) Int
{
    return a + b;
}

func zero() Int
{
    return 0;
}

func takesEnum(name Name) Void
{
    if (name == Name.Albert)
    {
        puts("albert");
    }
}

func takesStruct(point Point) Void
{
}

func print(msg String) Void
{
    puts("Hello");
}

func hello(num Int, othernum Int) Int
{
    val sum Int = num + othernum;
    return sum;
}

func makeArray(a Int, b Int, c Int) [3]Int
{
    return [a, b, c];
}

func takeArray(a [3]Int) [3]Int
{
    return a;
}

func returnFunPtr() *func(Int, Int) Int
    return &add;

func genericFunction<A, B>(a A, b B) A
{
    val arrayA = [a, a, a];
    val arrayB = [b, b];

    genericFunction.<A, B>(a, b);
    genericFunction.<B, A>(b, a);
    // val genericStruct = GenericStruct.<A, B> { a = 5, b = false };

    return arrayA[2];
}